use std::str;

use can_dbc_pest::{DbcParser, Parser as _, Rule};

use crate::ast::{
    AttributeDefault, AttributeDefinition, AttributeValueForObject, Baudrate, Comment,
    EnvironmentVariable, EnvironmentVariableData, ExtendedMultiplex, Message, MessageId,
    MessageTransmitter, MultiplexIndicator, Node, Signal, SignalExtendedValueType,
    SignalExtendedValueTypeList, SignalGroups, SignalType, SignalTypeRef, Symbol, ValDescription,
    ValueDescription, ValueTable, Version,
};
use crate::parser::{collect_all, DbcError, DbcResult};

#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Dbc {
    /// Version generated by DB editor
    pub version: Version,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub new_symbols: Vec<Symbol>,
    /// Baud rate of network
    pub bit_timing: Option<Vec<Baudrate>>,
    /// CAN network nodes
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub nodes: Vec<Node>,
    /// Global value table
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub value_tables: Vec<ValueTable>,
    /// CAN message (frame) details including signal details
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub messages: Vec<Message>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub message_transmitters: Vec<MessageTransmitter>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub environment_variables: Vec<EnvironmentVariable>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub environment_variable_data: Vec<EnvironmentVariableData>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_types: Vec<SignalType>,
    /// Object comments
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub comments: Vec<Comment>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_definitions: Vec<AttributeDefinition>,
    // undefined
    // sigtype_attr_list: SigtypeAttrList,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_defaults: Vec<AttributeDefault>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_values: Vec<AttributeValueForObject>,
    /// Encoding for signal raw values
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub value_descriptions: Vec<ValueDescription>,
    // obsolete + undefined
    // category_definitions: Vec<CategoryDefinition>,
    // obsolete + undefined
    //categories: Vec<Category>,
    // obsolete + undefined
    //filter: Vec<Filter>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_type_refs: Vec<SignalTypeRef>,
    /// Signal groups define a group of signals within a message
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_groups: Vec<SignalGroups>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_extended_value_type_list: Vec<SignalExtendedValueTypeList>,
    /// Extended multiplex attributes
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub extended_multiplex: Vec<ExtendedMultiplex>,
}

impl Dbc {
    pub fn signal_by_name(&self, message_id: MessageId, signal_name: &str) -> Option<&Signal> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            return message
                .signals
                .iter()
                .find(|signal| signal.name == *signal_name);
        }
        None
    }

    /// Lookup a message comment
    pub fn message_comment(&self, message_id: MessageId) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Message {
                id: ref x_message_id,
                ref comment,
            } => {
                if *x_message_id == message_id {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup a signal comment
    pub fn signal_comment(&self, message_id: MessageId, signal_name: &str) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                comment,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup value descriptions for signal
    pub fn value_descriptions_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&[ValDescription]> {
        self.value_descriptions.iter().find_map(|x| match x {
            ValueDescription::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                ref value_descriptions,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(value_descriptions.as_slice())
                } else {
                    None
                }
            }
            ValueDescription::EnvironmentVariable { .. } => None,
        })
    }

    /// Lookup the extended value for a given signal
    pub fn extended_value_type_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&SignalExtendedValueType> {
        self.signal_extended_value_type_list.iter().find_map(|x| {
            let SignalExtendedValueTypeList {
                message_id: ref x_message_id,
                signal_name: ref x_signal_name,
                ref signal_extended_value_type,
            } = x;
            if *x_message_id == message_id && x_signal_name == signal_name {
                Some(signal_extended_value_type)
            } else {
                None
            }
        })
    }

    /// Lookup the message multiplexer switch signal for a given message
    /// This does not work for extended multiplexed messages, if multiple multiplexors are defined for a message an Error is returned.
    #[allow(clippy::result_large_err)]
    pub fn message_multiplexor_switch(&self, message_id: MessageId) -> DbcResult<Option<&Signal>> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            if self
                .extended_multiplex
                .iter()
                .any(|ext_mp| ext_mp.message_id == message_id)
            {
                Err(DbcError::MultipleMultiplexors)
            } else {
                Ok(message
                    .signals
                    .iter()
                    .find(|signal| signal.multiplexer_indicator == MultiplexIndicator::Multiplexor))
            }
        } else {
            Ok(None)
        }
    }
}

impl<'a> TryFrom<&'a str> for Dbc {
    type Error = DbcError;

    fn try_from(dbc_in: &'a str) -> Result<Self, Self::Error> {
        dbc(dbc_in)
    }
}

pub(crate) fn dbc(buffer: &str) -> DbcResult<Dbc> {
    let mut version: Version = Version::default();
    let mut new_symbols: Vec<Symbol> = vec![];
    let mut bit_timing: Option<Vec<Baudrate>> = None;
    let mut nodes: Vec<Node> = vec![];
    let mut value_tables: Vec<ValueTable> = vec![];
    let mut messages: Vec<Message> = vec![];
    let mut signals: Vec<(usize, Signal)> = vec![]; // Store signals with their message index
    let mut message_transmitters: Vec<MessageTransmitter> = vec![];
    let mut environment_variables: Vec<EnvironmentVariable> = vec![];
    let mut environment_variable_data: Vec<EnvironmentVariableData> = vec![];
    let mut comments: Vec<Comment> = vec![];
    let mut attribute_definitions: Vec<AttributeDefinition> = vec![];
    let mut attribute_defaults: Vec<AttributeDefault> = vec![];
    let mut attribute_values: Vec<AttributeValueForObject> = vec![];
    let mut value_descriptions: Vec<ValueDescription> = vec![];
    let mut signal_groups: Vec<SignalGroups> = vec![];
    let mut signal_extended_value_type_list: Vec<SignalExtendedValueTypeList> = vec![];
    let mut extended_multiplex: Vec<ExtendedMultiplex> = vec![];

    let mut current_message_index: Option<usize> = None;

    for pair in DbcParser::parse(Rule::file, buffer)? {
        if !matches!(pair.as_rule(), Rule::file) {
            return Err(DbcError::Expected(Rule::file, pair.as_rule()));
        }
        for pairs in pair.into_inner() {
            match pairs.as_rule() {
                Rule::version => version = pairs.try_into()?,
                Rule::new_symbols => {
                    let symbols: Vec<Symbol> = collect_all::<Symbol>(&mut pairs.into_inner())?;
                    new_symbols.extend(symbols);
                }
                Rule::bit_timing => {
                    let inner_pairs = pairs.into_inner();
                    if inner_pairs.len() == 0 {
                        bit_timing = Some(vec![]);
                    } else {
                        // For now, just return empty vec since bit timing parsing is not implemented
                        bit_timing = Some(vec![]);
                    }
                }
                Rule::nodes => nodes = collect_all::<Node>(&mut pairs.into_inner())?,
                Rule::message => {
                    messages.push(pairs.try_into()?);
                    current_message_index = Some(messages.len() - 1);
                }
                Rule::signal => {
                    // TODO: consider modifying pest grammar to directly associate signals with messages
                    if let Some(msg_idx) = current_message_index {
                        signals.push((msg_idx, pairs.try_into()?));
                    } else {
                        return Err(DbcError::SignalWithoutMessage);
                    }
                }
                Rule::comment => {
                    comments.push(pairs.try_into()?);
                }
                Rule::attr_def => attribute_definitions.push(pairs.try_into()?),
                Rule::attr_value => attribute_values.push(pairs.try_into()?),
                Rule::value_table => value_tables.push(pairs.try_into()?),
                Rule::value_table_def => value_descriptions.push(pairs.try_into()?),
                Rule::signal_group => signal_groups.push(pairs.try_into()?),
                Rule::signal_value_type => {
                    signal_extended_value_type_list.push(pairs.try_into()?);
                }
                Rule::message_transmitter => message_transmitters.push(pairs.try_into()?),
                Rule::ba_def_def => attribute_defaults.push(pairs.try_into()?),
                Rule::sg_mul_val => extended_multiplex.push(pairs.try_into()?),
                Rule::environment_variable => {
                    environment_variables.push(pairs.try_into()?);
                }
                Rule::env_var_data => environment_variable_data.push(pairs.try_into()?),
                Rule::ba_def_rel => return Err(DbcError::NotImplemented("ba_def_rel")),
                Rule::ba_def_def_rel => return Err(DbcError::NotImplemented("ba_def_def_rel")),
                Rule::ba_rel => return Err(DbcError::NotImplemented("ba_rel")),
                Rule::EOI => {
                    // ignore
                }
                other => panic!("Unexpected rule in DBC file: {other:?}"),
            }
        }
    }

    // Associate signals with their messages using index-based association
    for (msg_idx, signal) in signals {
        if msg_idx < messages.len() {
            messages[msg_idx].signals.push(signal);
        }
    }

    Ok(Dbc {
        version,
        new_symbols,
        bit_timing,
        nodes,
        value_tables,
        messages,
        message_transmitters,
        environment_variables,
        environment_variable_data,
        signal_types: vec![], // TODO
        comments,
        attribute_definitions,
        attribute_defaults,
        attribute_values,
        value_descriptions,
        signal_type_refs: vec![], // TODO
        signal_groups,
        signal_extended_value_type_list,
        extended_multiplex,
    })
}
