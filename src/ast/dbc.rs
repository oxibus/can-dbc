use crate::ast::{
    AttributeDefault, AttributeDefinition, AttributeValueForObject, Baudrate, Comment,
    EnvironmentVariable, EnvironmentVariableData, ExtendedMultiplex, Message, MessageId,
    MessageTransmitter, MultiplexIndicator, Node, Signal, SignalExtendedValueType,
    SignalExtendedValueTypeList, SignalGroups, SignalType, SignalTypeRef, Symbol, ValDescription,
    ValueDescription, ValueTable, Version,
};
use crate::{parser, DbcError, DbcResult};

#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Dbc {
    /// Version generated by DB editor
    pub version: Version,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub new_symbols: Vec<Symbol>,
    /// Baud rate of network
    pub bit_timing: Option<Vec<Baudrate>>,
    /// CAN network nodes
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub nodes: Vec<Node>,
    /// Global value table
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub value_tables: Vec<ValueTable>,
    /// CAN message (frame) details including signal details
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub messages: Vec<Message>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub message_transmitters: Vec<MessageTransmitter>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub environment_variables: Vec<EnvironmentVariable>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub environment_variable_data: Vec<EnvironmentVariableData>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_types: Vec<SignalType>,
    /// Object comments
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub comments: Vec<Comment>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_definitions: Vec<AttributeDefinition>,
    // undefined
    // sigtype_attr_list: SigtypeAttrList,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_defaults: Vec<AttributeDefault>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_values: Vec<AttributeValueForObject>,
    /// Encoding for signal raw values
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub value_descriptions: Vec<ValueDescription>,
    // obsolete + undefined
    // category_definitions: Vec<CategoryDefinition>,
    // obsolete + undefined
    //categories: Vec<Category>,
    // obsolete + undefined
    //filter: Vec<Filter>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_type_refs: Vec<SignalTypeRef>,
    /// Signal groups define a group of signals within a message
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_groups: Vec<SignalGroups>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_extended_value_type_list: Vec<SignalExtendedValueTypeList>,
    /// Extended multiplex attributes
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub extended_multiplex: Vec<ExtendedMultiplex>,
}

impl Dbc {
    pub fn signal_by_name(&self, message_id: MessageId, signal_name: &str) -> Option<&Signal> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            return message
                .signals
                .iter()
                .find(|signal| signal.name == *signal_name);
        }
        None
    }

    /// Lookup a message comment
    pub fn message_comment(&self, message_id: MessageId) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Message {
                id: ref x_message_id,
                ref comment,
            } => {
                if *x_message_id == message_id {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup a signal comment
    pub fn signal_comment(&self, message_id: MessageId, signal_name: &str) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                comment,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup value descriptions for signal
    pub fn value_descriptions_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&[ValDescription]> {
        self.value_descriptions.iter().find_map(|x| match x {
            ValueDescription::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                ref value_descriptions,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(value_descriptions.as_slice())
                } else {
                    None
                }
            }
            ValueDescription::EnvironmentVariable { .. } => None,
        })
    }

    /// Lookup the extended value for a given signal
    pub fn extended_value_type_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&SignalExtendedValueType> {
        self.signal_extended_value_type_list.iter().find_map(|x| {
            let SignalExtendedValueTypeList {
                message_id: ref x_message_id,
                signal_name: ref x_signal_name,
                ref signal_extended_value_type,
            } = x;
            if *x_message_id == message_id && x_signal_name == signal_name {
                Some(signal_extended_value_type)
            } else {
                None
            }
        })
    }

    /// Lookup the message multiplexor switch signal for a given message
    /// This does not work for extended multiplexed messages, if multiple multiplexors are defined for a message an Error is returned.
    #[allow(clippy::result_large_err)]
    pub fn message_multiplexor_switch(&self, message_id: MessageId) -> DbcResult<Option<&Signal>> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            if self
                .extended_multiplex
                .iter()
                .any(|ext_mp| ext_mp.message_id == message_id)
            {
                Err(DbcError::MultipleMultiplexors)
            } else {
                Ok(message
                    .signals
                    .iter()
                    .find(|signal| signal.multiplexer_indicator == MultiplexIndicator::Multiplexor))
            }
        } else {
            Ok(None)
        }
    }
}

impl<'a> TryFrom<&'a str> for Dbc {
    type Error = DbcError;

    fn try_from(dbc_in: &'a str) -> Result<Self, Self::Error> {
        parser::dbc(dbc_in)
    }
}
