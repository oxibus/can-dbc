use std::str;

use can_dbc_pest::{DbcParser, Parser as _, Rule};

use crate::ast::{
    AttributeDefault, AttributeDefinition, AttributeValueForObject, Baudrate, Comment,
    EnvironmentVariable, EnvironmentVariableData, ExtendedMultiplex, Message, MessageId,
    MessageTransmitter, MultiplexIndicator, Node, Signal, SignalExtendedValueType,
    SignalExtendedValueTypeList, SignalGroups, SignalType, SignalTypeRef, Symbol, ValDescription,
    ValueDescription, ValueTable, Version,
};
use crate::parser::{DbcError, DbcResult};

#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Dbc {
    /// Version generated by DB editor
    pub version: Version,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub new_symbols: Vec<Symbol>,
    /// Baud rate of network
    pub bit_timing: Option<Vec<Baudrate>>,
    /// CAN network nodes
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub nodes: Vec<Node>,
    /// Global value table
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub value_tables: Vec<ValueTable>,
    /// CAN message (frame) details including signal details
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub messages: Vec<Message>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub message_transmitters: Vec<MessageTransmitter>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub environment_variables: Vec<EnvironmentVariable>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub environment_variable_data: Vec<EnvironmentVariableData>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_types: Vec<SignalType>,
    /// Object comments
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub comments: Vec<Comment>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_definitions: Vec<AttributeDefinition>,
    // undefined
    // sigtype_attr_list: SigtypeAttrList,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_defaults: Vec<AttributeDefault>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub attribute_values: Vec<AttributeValueForObject>,
    /// Encoding for signal raw values
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub value_descriptions: Vec<ValueDescription>,
    // obsolete + undefined
    // category_definitions: Vec<CategoryDefinition>,
    // obsolete + undefined
    //categories: Vec<Category>,
    // obsolete + undefined
    //filter: Vec<Filter>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_type_refs: Vec<SignalTypeRef>,
    /// Signal groups define a group of signals within a message
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_groups: Vec<SignalGroups>,
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub signal_extended_value_type_list: Vec<SignalExtendedValueTypeList>,
    /// Extended multiplex attributes
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub extended_multiplex: Vec<ExtendedMultiplex>,
}

impl Dbc {
    pub fn signal_by_name(&self, message_id: MessageId, signal_name: &str) -> Option<&Signal> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            return message
                .signals
                .iter()
                .find(|signal| signal.name == *signal_name);
        }
        None
    }

    /// Lookup a message comment
    pub fn message_comment(&self, message_id: MessageId) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Message {
                id: ref x_message_id,
                ref comment,
            } => {
                if *x_message_id == message_id {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup a signal comment
    pub fn signal_comment(&self, message_id: MessageId, signal_name: &str) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                comment,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup value descriptions for signal
    pub fn value_descriptions_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&[ValDescription]> {
        self.value_descriptions.iter().find_map(|x| match x {
            ValueDescription::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                ref value_descriptions,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(value_descriptions.as_slice())
                } else {
                    None
                }
            }
            ValueDescription::EnvironmentVariable { .. } => None,
        })
    }

    /// Lookup the extended value for a given signal
    pub fn extended_value_type_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&SignalExtendedValueType> {
        self.signal_extended_value_type_list.iter().find_map(|x| {
            let SignalExtendedValueTypeList {
                message_id: ref x_message_id,
                signal_name: ref x_signal_name,
                ref signal_extended_value_type,
            } = x;
            if *x_message_id == message_id && x_signal_name == signal_name {
                Some(signal_extended_value_type)
            } else {
                None
            }
        })
    }

    /// Lookup the message multiplexor switch signal for a given message
    /// This does not work for extended multiplexed messages, if multiple multiplexors are defined for a message an Error is returned.
    #[allow(clippy::result_large_err)]
    pub fn message_multiplexor_switch(&self, message_id: MessageId) -> DbcResult<Option<&Signal>> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            if self
                .extended_multiplex
                .iter()
                .any(|ext_mp| ext_mp.message_id == message_id)
            {
                Err(DbcError::MultipleMultiplexors)
            } else {
                Ok(message
                    .signals
                    .iter()
                    .find(|signal| signal.multiplexer_indicator == MultiplexIndicator::Multiplexor))
            }
        } else {
            Ok(None)
        }
    }
}

impl<'a> TryFrom<&'a str> for Dbc {
    type Error = DbcError;

    fn try_from(dbc_in: &'a str) -> Result<Self, Self::Error> {
        dbc(dbc_in)
    }
}

pub(crate) fn dbc(buffer: &str) -> DbcResult<Dbc> {
    let pairs = DbcParser::parse(Rule::file, buffer)?;

    let mut version: Version = Version::default();
    let mut new_symbols: Vec<Symbol> = vec![];
    let mut bit_timing: Option<Vec<Baudrate>> = None;
    let mut nodes: Vec<Node> = vec![];
    let mut value_tables: Vec<ValueTable> = vec![];
    let mut messages: Vec<Message> = vec![];
    let mut signals: Vec<(MessageId, Signal)> = vec![]; // Store signals with their message ID
    let mut message_transmitters: Vec<MessageTransmitter> = vec![];
    let mut environment_variables: Vec<EnvironmentVariable> = vec![];
    let mut environment_variable_data: Vec<EnvironmentVariableData> = vec![];
    let mut comments: Vec<Comment> = vec![];
    let mut attribute_definitions: Vec<AttributeDefinition> = vec![];
    let mut attribute_defaults: Vec<AttributeDefault> = vec![];
    let mut attribute_values: Vec<AttributeValueForObject> = vec![];
    let mut value_descriptions: Vec<ValueDescription> = vec![];
    let mut signal_groups: Vec<SignalGroups> = vec![];
    let mut signal_extended_value_type_list: Vec<SignalExtendedValueTypeList> = vec![];
    let mut extended_multiplex: Vec<ExtendedMultiplex> = vec![];

    let mut current_message_id: Option<MessageId> = None;

    for pair in pairs {
        if !matches!(pair.as_rule(), Rule::file) {
            return Err(DbcError::ParseError);
        }
        for pair2 in pair.into_inner() {
            match pair2.as_rule() {
                Rule::version => version = Version::parse(pair2)?,
                Rule::new_symbols => new_symbols = Symbol::parse_new_symbols(pair2)?,
                Rule::bit_timing => bit_timing = Some(Baudrate::parse_bit_timing(pair2)?),
                Rule::nodes => nodes = Node::parse_nodes(pair2)?,
                Rule::message => {
                    let message = Message::parse(pair2)?;
                    current_message_id = Some(message.id);
                    messages.push(message);
                }
                Rule::signal => {
                    if let Some(msg_id) = current_message_id {
                        signals.push((msg_id, Signal::parse(pair2)?));
                    }
                }
                Rule::comment => {
                    if let Some(comment) = Comment::parse(pair2)? {
                        comments.push(comment);
                    }
                }
                Rule::attr_def => attribute_definitions.push(AttributeDefinition::parse(pair2)?),
                Rule::attr_value => attribute_values.push(AttributeValueForObject::parse(pair2)?),
                Rule::value_table => value_tables.push(ValueTable::parse(pair2)?),
                Rule::value_table_def => value_descriptions.push(ValueDescription::parse(pair2)?),
                Rule::signal_group => signal_groups.push(SignalGroups::parse(pair2)?),
                Rule::signal_value_type => {
                    signal_extended_value_type_list
                        .push(SignalExtendedValueTypeList::parse(pair2)?);
                }
                Rule::bo_tx_bu => message_transmitters.push(MessageTransmitter::parse(pair2)?),
                Rule::ba_def_def => attribute_defaults.push(AttributeDefault::parse(pair2)?),
                Rule::sg_mul_val => extended_multiplex.push(ExtendedMultiplex::parse(pair2)?),
                Rule::environment_variable => {
                    environment_variables.push(EnvironmentVariable::parse(pair2)?);
                }
                Rule::envvar_data => {
                    environment_variable_data.push(EnvironmentVariableData::parse(pair2)?);
                }
                Rule::ba_def_rel => return Err(DbcError::NotImplemented("ba_def_rel")),
                Rule::ba_def_def_rel => return Err(DbcError::NotImplemented("ba_def_def_rel")),
                Rule::ba_rel => return Err(DbcError::NotImplemented("ba_rel")),
                Rule::EOI => {
                    // ignore
                }
                other => panic!("What is this? {other:?}"),
            }
        }
    }

    // Associate signals with their messages
    for (msg_id, signal) in signals {
        if let Some(message) = messages.iter_mut().find(|m| m.id == msg_id) {
            message.signals.push(signal);
        }
    }

    Ok(Dbc {
        version,
        new_symbols,
        bit_timing,
        nodes,
        value_tables,
        messages,
        message_transmitters,
        environment_variables,
        environment_variable_data,
        signal_types: vec![], // TODO
        comments,
        attribute_definitions,
        attribute_defaults,
        attribute_values,
        value_descriptions,
        signal_type_refs: vec![], // TODO
        signal_groups,
        signal_extended_value_type_list,
        extended_multiplex,
    })
}
