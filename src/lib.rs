#![doc = include_str!("../README.md")]

use std::borrow::Cow;
use std::convert::TryFrom;

use derive_getters::Getters;
use serde::{Deserialize, Serialize};

pub mod parser;

#[cfg(test)]
mod parser_tests;

/// Re-export of `encoding_rs` as encodings to simplify usage
#[cfg(feature = "encodings")]
pub use encoding_rs as encodings;

/// A helper function to decode cp1252 bytes, as DBC files are often encoded in cp1252.
#[cfg(feature = "encodings")]
pub fn decode_cp1252(bytes: &[u8]) -> Option<Cow<'_, str>> {
    let (cow, _, had_errors) = encodings::WINDOWS_1252.decode(bytes);
    if had_errors {
        None
    } else {
        Some(cow)
    }
}

/// Possible error cases for `can-dbc`
#[allow(clippy::large_enum_variant)]
#[derive(Debug)]
pub enum Error<'a> {
    /// Remaining String, the DBC was only read partially.
    /// Occurs when e.g. an unexpected symbol occurs.
    Incomplete(Dbc, &'a str),
    /// Parser failed
    Nom(nom::Err<nom::error::Error<&'a str>>),
    /// Can't Lookup multiplexors because the message uses extended multiplexing.
    MultipleMultiplexors,
}

/// Baudrate of network in kbit/s
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Baudrate(u64);

/// One or multiple signals are the payload of a CAN frame.
/// To determine the actual value of a signal the following fn applies:
/// `let fnvalue = |can_signal_value| -> can_signal_value * factor + offset;`
#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct Signal {
    name: String,
    multiplexer_indicator: MultiplexIndicator,
    pub start_bit: u64,
    pub size: u64,
    byte_order: ByteOrder,
    value_type: ValueType,
    pub factor: f64,
    pub offset: f64,
    pub min: f64,
    pub max: f64,
    unit: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    receivers: Vec<String>,
}

/// CAN id in header of CAN frame.
/// Must be unique in DBC file.
#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum MessageId {
    Standard(u16),
    /// 29 bit extended identifier without the extended bit.
    /// For the raw value of the message id including the bit for extended identifiers use the `raw()` method.
    Extended(u32),
}

impl MessageId {
    /// Raw value of the message id including the bit for extended identifiers
    pub fn raw(self) -> u32 {
        match self {
            MessageId::Standard(id) => u32::from(id),
            MessageId::Extended(id) => id | 1 << 31,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Transmitter {
    /// node transmitting the message
    NodeName(String),
    /// message has no sender
    VectorXXX,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct MessageTransmitter {
    message_id: MessageId,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    transmitter: Vec<Transmitter>,
}

/// Version generated by DB editor
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Version(pub String);

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Symbol(pub String);

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum MultiplexIndicator {
    /// Multiplexor switch
    Multiplexor,
    /// Signal us being multiplexed by the multiplexer switch.
    MultiplexedSignal(u64),
    /// Signal us being multiplexed by the multiplexer switch and itself is a multiplexor
    MultiplexorAndMultiplexedSignal(u64),
    /// Normal signal
    Plain,
}

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ByteOrder {
    LittleEndian,
    BigEndian,
}

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ValueType {
    Signed,
    Unsigned,
}

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum EnvType {
    Float,
    U64,
    Data,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct SignalType {
    name: String,
    signal_size: u64,
    byte_order: ByteOrder,
    value_type: ValueType,
    factor: f64,
    offset: f64,
    min: f64,
    max: f64,
    unit: String,
    default_value: f64,
    value_table: String,
}

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AccessType {
    DummyNodeVector0,
    DummyNodeVector1,
    DummyNodeVector2,
    DummyNodeVector3,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AccessNode {
    VectorXXX,
    Name(String),
}

// FIXME: not used!
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SignalAttributeValue {
    Text(String),
    Int(i64),
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AttributeValuedForObjectType {
    Raw(AttributeValue),
    NetworkNode(String, AttributeValue),
    MessageDefinition(MessageId, Option<AttributeValue>),
    Signal(MessageId, String, AttributeValue),
    EnvVariable(String, AttributeValue),
}

// FIXME: not used!
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AttributeValueType {
    Int(i64, i64),
    Hex(i64, i64),
    Float(f64, f64),
    String,
    Enum(Vec<String>),
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct ValDescription {
    pub id: f64,
    pub description: String,
}

// FIXME: not used!
#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct AttrDefault {
    name: String,
    value: AttributeValue,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AttributeValue {
    U64(u64),
    I64(i64),
    Double(f64),
    String(String),
}

/// Global value table
#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct ValueTable {
    name: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    descriptions: Vec<ValDescription>,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct ExtendedMultiplexMapping {
    min_value: u64,
    max_value: u64,
}

/// Mapping between multiplexors and multiplexed signals
#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct ExtendedMultiplex {
    message_id: MessageId,
    signal_name: String,
    multiplexor_signal_name: String,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    mappings: Vec<ExtendedMultiplexMapping>,
}

/// Object comments
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Comment {
    Node {
        name: String,
        comment: String,
    },
    Message {
        id: MessageId,
        comment: String,
    },
    Signal {
        message_id: MessageId,
        name: String,
        comment: String,
    },
    EnvVar {
        name: String,
        comment: String,
    },
    Plain {
        comment: String,
    },
}

/// CAN message (frame) details including signal details
#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct Message {
    /// CAN id in header of CAN frame.
    /// Must be unique in DBC file.
    id: MessageId,
    name: String,
    size: u64,
    transmitter: Transmitter,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    signals: Vec<Signal>,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct EnvironmentVariable {
    name: String,
    typ: EnvType,
    min: i64,
    max: i64,
    unit: String,
    initial_value: f64,
    ev_id: i64,
    access_type: AccessType,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    access_nodes: Vec<AccessNode>,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct EnvironmentVariableData {
    env_var_name: String,
    data_size: u64,
}

/// CAN network nodes, names must be unique
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Node(pub String);

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct AttributeDefault {
    name: String,
    value: AttributeValue,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct AttributeValueForObject {
    name: String,
    value: AttributeValuedForObjectType,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AttributeDefinition {
    // TODO add properties
    Message(String),
    // TODO add properties
    Node(String),
    // TODO add properties
    Signal(String),
    EnvironmentVariable(String),
    // TODO figure out name
    Plain(String),
}

/// Encoding for signal raw values.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum ValueDescription {
    Signal {
        message_id: MessageId,
        name: String,
        #[serde(skip_serializing_if = "Vec::is_empty")]
        value_descriptions: Vec<ValDescription>,
    },
    EnvironmentVariable {
        name: String,
        #[serde(skip_serializing_if = "Vec::is_empty")]
        value_descriptions: Vec<ValDescription>,
    },
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct SignalTypeRef {
    message_id: MessageId,
    signal_name: String,
    signal_type_name: String,
}

/// Signal groups define a group of signals within a message
#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct SignalGroups {
    message_id: MessageId,
    name: String,
    repetitions: u64,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    signal_names: Vec<String>,
}

#[derive(Copy, Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum SignalExtendedValueType {
    SignedOrUnsignedInteger,
    IEEEfloat32Bit,
    IEEEdouble64bit,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct SignalExtendedValueTypeList {
    message_id: MessageId,
    signal_name: String,
    signal_extended_value_type: SignalExtendedValueType,
}

#[derive(Clone, Debug, PartialEq, Getters, Serialize, Deserialize)]
pub struct Dbc {
    /// Version generated by DB editor
    version: Version,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    new_symbols: Vec<Symbol>,
    /// Baud rate of network
    bit_timing: Option<Vec<Baudrate>>,
    /// CAN network nodes
    #[serde(skip_serializing_if = "Vec::is_empty")]
    nodes: Vec<Node>,
    /// Global value table
    #[serde(skip_serializing_if = "Vec::is_empty")]
    value_tables: Vec<ValueTable>,
    /// CAN message (frame) details including signal details
    #[serde(skip_serializing_if = "Vec::is_empty")]
    messages: Vec<Message>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    message_transmitters: Vec<MessageTransmitter>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    environment_variables: Vec<EnvironmentVariable>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    environment_variable_data: Vec<EnvironmentVariableData>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    signal_types: Vec<SignalType>,
    /// Object comments
    #[serde(skip_serializing_if = "Vec::is_empty")]
    comments: Vec<Comment>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    attribute_definitions: Vec<AttributeDefinition>,
    // undefined
    // sigtype_attr_list: SigtypeAttrList,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    attribute_defaults: Vec<AttributeDefault>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    attribute_values: Vec<AttributeValueForObject>,
    /// Encoding for signal raw values
    #[serde(skip_serializing_if = "Vec::is_empty")]
    value_descriptions: Vec<ValueDescription>,
    // obsolete + undefined
    // category_definitions: Vec<CategoryDefinition>,
    // obsolete + undefined
    //categories: Vec<Category>,
    // obsolete + undefined
    //filter: Vec<Filter>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    signal_type_refs: Vec<SignalTypeRef>,
    /// Signal groups define a group of signals within a message
    #[serde(skip_serializing_if = "Vec::is_empty")]
    signal_groups: Vec<SignalGroups>,
    #[serde(skip_serializing_if = "Vec::is_empty")]
    signal_extended_value_type_list: Vec<SignalExtendedValueTypeList>,
    /// Extended multiplex attributes
    #[serde(skip_serializing_if = "Vec::is_empty")]
    extended_multiplex: Vec<ExtendedMultiplex>,
}

impl Dbc {
    pub fn signal_by_name(&self, message_id: MessageId, signal_name: &str) -> Option<&Signal> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            return message
                .signals
                .iter()
                .find(|signal| signal.name == *signal_name);
        }
        None
    }

    /// Lookup a message comment
    pub fn message_comment(&self, message_id: MessageId) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Message {
                id: ref x_message_id,
                ref comment,
            } => {
                if *x_message_id == message_id {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup a signal comment
    pub fn signal_comment(&self, message_id: MessageId, signal_name: &str) -> Option<&str> {
        self.comments.iter().find_map(|x| match x {
            Comment::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                comment,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(comment.as_str())
                } else {
                    None
                }
            }
            _ => None,
        })
    }

    /// Lookup value descriptions for signal
    pub fn value_descriptions_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&[ValDescription]> {
        self.value_descriptions.iter().find_map(|x| match x {
            ValueDescription::Signal {
                message_id: ref x_message_id,
                name: ref x_signal_name,
                ref value_descriptions,
            } => {
                if *x_message_id == message_id && x_signal_name == signal_name {
                    Some(value_descriptions.as_slice())
                } else {
                    None
                }
            }
            ValueDescription::EnvironmentVariable { .. } => None,
        })
    }

    /// Lookup the extended value for a given signal
    pub fn extended_value_type_for_signal(
        &self,
        message_id: MessageId,
        signal_name: &str,
    ) -> Option<&SignalExtendedValueType> {
        self.signal_extended_value_type_list.iter().find_map(|x| {
            let SignalExtendedValueTypeList {
                message_id: ref x_message_id,
                signal_name: ref x_signal_name,
                ref signal_extended_value_type,
            } = x;
            if *x_message_id == message_id && x_signal_name == signal_name {
                Some(signal_extended_value_type)
            } else {
                None
            }
        })
    }

    /// Lookup the message multiplexor switch signal for a given message
    /// This does not work for extended multiplexed messages, if multiple multiplexors are defined for a message a Error is returned.
    #[allow(clippy::result_large_err)]
    pub fn message_multiplexor_switch(
        &self,
        message_id: MessageId,
    ) -> Result<Option<&Signal>, Error<'_>> {
        let message = self
            .messages
            .iter()
            .find(|message| message.id == message_id);

        if let Some(message) = message {
            if self
                .extended_multiplex
                .iter()
                .any(|ext_mp| ext_mp.message_id == message_id)
            {
                Err(Error::MultipleMultiplexors)
            } else {
                Ok(message
                    .signals
                    .iter()
                    .find(|signal| signal.multiplexer_indicator == MultiplexIndicator::Multiplexor))
            }
        } else {
            Ok(None)
        }
    }
}

impl<'a> TryFrom<&'a str> for Dbc {
    type Error = Error<'a>;

    fn try_from(dbc_in: &'a str) -> Result<Self, Self::Error> {
        let (remaining, dbc) = parser::dbc(dbc_in).map_err(Error::Nom)?;
        if !remaining.is_empty() {
            return Err(Error::Incomplete(dbc, remaining));
        }
        Ok(dbc)
    }
}
